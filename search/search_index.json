{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to SPEADI's Documentation Page","text":"<p><code>SPEADI</code> is a Python package that aims to characterise the dynamics of local chemical environments from Molecular  Dynamics trajectories of proteins and other biomolecules.</p> <p></p>"},{"location":"#introduction","title":"Introduction","text":"<p>SPEADI provides the user tools with which to characterise the local chemical environment using Molecular Dynamics data.  At the moment, it implements two variations of the pair radial distribution function (RDF): time-resolved RDFs (TRRDFs)  and van Hove dynamic correlation functions (VHFs).</p>"},{"location":"#quick-install","title":"Quick install","text":"<p>For installation into the default python environment, run the following pip command in a terminal:</p> <pre><code>pip install git+https://github.com/FZJ-JSC/speadi.git\n</code></pre> <p>Or, to install just into the current user's local environment, add the <code>--user</code> option:</p> <pre><code>pip install --user git+https://github.com/FZJ-JSC/speadi.git\n</code></pre>"},{"location":"#rdfs","title":"RDFs","text":"<p>Normally, Radial Distribution Functions used in atomistic simulations are averaged over entire trajectories. <code>SPEADI</code>  averages over user-defined windows of time. This gives a separate RDF between group a and b for each window in the  trajectory.</p>"},{"location":"#time-resolved-rdfs","title":"Time-resolved RDFs","text":"<p>This package provides a method to calculate Time-resolved Radial Distribution Functions using atomistic simulation  trajectory data. This is implemented efficiently using <code>Numpy</code> arrays and the <code>Numba</code> package when available.  Trajectory data may be anything that the package <code>MDTraj</code> can handle, or preferably a string pointing to the location of such data.</p>"},{"location":"#data-requirements","title":"Data requirements","text":"<p>The trajectory data used must be sampled to a sufficient degree. The sampling frequency of the input data naturally  determines the time-resolving capability of the time-resolved RDF. When using both small groups for reference particles  and selection particles, the sampling frequency must be high enough to provide an ensemble of distances in each time  slice that provides a satisfactory signal-to-noise ratio.</p> <p>In RDFs of particular ions around selected single atoms in all-atom simulations of biomolecules, experience suggests a  sampling frequency of below 1 picosecond and window lengths of 1-10 picoseconds to follow changes in coordination shells of atoms.</p>"},{"location":"#van-hove-functions","title":"van Hove functions","text":"<p>This package also provides a method to calculate the van Hove dynamic correlation function using atomistic simulation  trajectory data. This is also implemented efficiently using <code>Numpy</code> arrays and the <code>Numba</code> package when available.  Trajectory data may be anything that the package <code>MDTraj</code> can handle, or preferably a string pointing to the location of such data.</p>"},{"location":"#data-requirements_1","title":"Data requirements","text":"<p>As with TRRDFs, the input trajectory data must be sampled above a certain frequency. Window lengths of 1-2 picoseconds  are enough to follow the loss in structure in all-atom simulations of water, with each window containing anything above  10 samples.</p> <p>VHFs of ions around single atoms in do not require sample frequencies above those consistent with the time-scale of the  movement of ions, yet they do require a larger number of windows to average over. This number of windows can either be  supplied by using a trajectory or trajectory slice of preferably at least 10 ns in length, or alternatively by using a  sliding window over a trajectory slice of at least 1 ns in length.</p>"},{"location":"#installation","title":"Installation","text":"<p>Installation is provided easily through <code>pip</code>. It can be installed either directly as a package, or as an editable source.</p>"},{"location":"#acceleration","title":"Acceleration","text":"<p>As a default, <code>SPEADI</code> doesn't install <code>JAX</code> or <code>Numba</code>, but uses these if detected in the same Python environment that  <code>SPEADI</code> is installed into.</p> <p>To install <code>JAX</code> and <code>jaxlib</code> along with <code>SPEADI</code>, simply add the <code>jax</code> extra to <code>pip</code>: <pre><code>pip install 'git+https://github.com/FZJ-JSC/speadi.git#egg=speadi[jax]'\n</code></pre> Note that by default, installing <code>jax</code> using pip (through pypi) only enables CPU acceleration. To enable GPU or TPU  acceleration, please see https://github.com/google/jax for details on how to obtain a <code>JAX</code> installation for the  specific <code>CuDNN</code> version in your environment.</p> <p>To install <code>Numba</code> along with <code>SPEADI</code>, simply add the <code>numba</code> extra to <code>pip</code>: <pre><code>pip install 'git+https://github.com/FZJ-JSC/speadi.git#egg=speadi[numba]'\n</code></pre></p> <p>Or, to install both <code>jax</code> and <code>numba</code> alongside <code>SPEADI</code>, add the <code>all</code> extra to <code>pip</code>: <pre><code>pip install 'git+https://github.com/FZJ-JSC/speadi.git#egg=speadi[all]'\n</code></pre> The <code>--user</code> pip option may be added to all of these commands to install just for the current user.</p>"},{"location":"#editable-source-installation","title":"Editable source installation","text":"<p>Open up a terminal. Navigate to the location you want to clone this repository. Then, run the following to clone the  entire repository: <pre><code>git clone https://github.com/FZJ-JSC/speadi\n</code></pre></p> <p>Then, install locally using <code>pip</code> by adding the <code>-e</code> option: <pre><code>pip install -e SPEADI \n</code></pre></p>"},{"location":"#usage","title":"Usage","text":""},{"location":"#time-resolved-radial-distribution-functions-trrdfs","title":"Time-Resolved Radial Distribution Functions (TRRDFs)","text":"<p>To calculate the time-resolved RDF for every single protein heavy atom with each ion species in solvent, you first need  to specify the trajectory and topology to be used: <pre><code>topology = './topology.gro'\ntrajectory = './trajectory.xtc'\n</code></pre></p> <p>Next, load the topology in <code>MDTraj</code> and subset into useful groups: <pre><code>import mdtraj as md\n\ntop = md.load_topology(topology)\nna = top.select('name NA')\ncl = top.select('name CL')\nprotein_by_atom = [top.select(f'index {ix}') \n                   for ix in top.select('protein and not type H')]\n</code></pre></p> <p>Now you can load <code>SPEADI</code> to obtain RDFs: <pre><code>import speadi as sp\n</code></pre></p> <p>To make an RDF for each heavy protein atom <pre><code>r, g_rt = sp.trrdf(trajectory, protein_by_atom, [na, cl], \n                    top=top, n_windows=1000, window_size=500,\n                    skip=0, pbc='general', stride=1, nbins=400)\n</code></pre></p> <p>To repeat the analysis, but obtain integral of \\(g(r)\\) instead, simply replace <code>trrdf</code> with <code>int_trrdf</code> instead. <pre><code>r, n_rt = sp.int_trrdf(trajectory, protein_by_atom, [na, cl], \n                        top=top, n_windows=1000, window_size=500,\n                        skip=0, pbc='general', stride=1, nbins=400)\n</code></pre></p>"},{"location":"#van-hove-functions-vhfs","title":"Van-Hove Functions (VHFs)","text":"<p>First, load a topology as above using <code>MDTraj</code>, then define the reference and target groups: <pre><code>import mdtraj as md\n\ntop = md.load_topology(topology)\nwater_H = top.select('name HW2')\ntarget_atom = top.select('resid 129 and name OG')\n</code></pre> In this example, we're looking at the stability of the water structure surrounding the side-chain terminal oxygen in a  serine residue.</p> <p>Next, calculate the VHF for this site over the whole trajectory: <pre><code>r, G_s, G_d = sp.vanhove(trajectory, target_atom, [water_H], \n                        top=top, n_windows=1000, window_size=500,\n                        skip=0, pbc='general', stride=1, nbins=400)\n</code></pre> As the reference and target particles are non-identical, \\(G_s\\) is empty. The distinct part, \\(G_d\\), gives us the  time-dependent dynamic correlation between the two types of particles.</p>"},{"location":"#wip-citing-speadi","title":"[WIP] Citing <code>SPEADI</code>","text":"<p>Add Zenodo link when tagging first release version.</p> <p>Add DOI of Paper after preprint and/or acceptance.</p>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<p>We gratefully acknowledge the following institutions for their support in the development of SPEADI and for  granting compute time to develop and test SPEADI.</p> <ul> <li>Gauss Centre for Supercomputing e.V. (www.gauss-centre.eu) and the John von Neumann Institute for Computing (NIC)</li> </ul> <p>on the GCS Supercomputer JUWELS at J\u00fclich Supercomputing Centre (JSC)</p> <ul> <li>HDS-LEE Helmholtz Graduate School</li> </ul>"},{"location":"#copyright","title":"Copyright","text":"<p>SPEADI  Copyright \u00a9 2022 Forschungszentrum J\u00fclich GmbH, J\u00fclich Supercomputing Centre and the Authors</p>"},{"location":"#license","title":"License","text":"<p>This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.</p> <p>This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.</p>"},{"location":"TRRDFs/","title":"Time-resolved Radial Distribution Functions (TRRDFs)","text":""},{"location":"TRRDFs/#pair-correlation-function-grt","title":"Pair-correlation function g(r,t)","text":"<p>Provides functions to calculate the radial distribution function (RDF) between two groups of particles for specified windows along a trajectory g(r,t). Groups can also consist of single particles.</p>"},{"location":"TRRDFs/#speadi.time_resolved_rdf.trrdf.trrdf","title":"trrdf","text":"<pre><code>trrdf(\n    traj,\n    g1,\n    g2,\n    top=None,\n    pbc=\"ortho\",\n    n_windows=100,\n    window_size=200,\n    skip=1,\n    stride=10,\n    r_range=(0.0, 2.0),\n    nbins=400,\n)\n</code></pre> <p>Calculate g(r,t) for two groups given in a trajectory. g(r) is calculated for each frame in the trajectory, then averaged over specified windows of time, returning g(r,t) (where t represents the window time along the trajectory).</p> PARAMETER DESCRIPTION <code>traj</code> <p>String pointing to the location of a trajectory that MDTraj is able to load</p> <p> TYPE: <code>str</code> </p> <code>g1</code> <p>List of numpy arrays of atom indices representing the group to calculate G(r,t) for</p> <p> TYPE: <code>list</code> </p> <code>g2</code> <p>List of numpy arrays of atom indices representing the group to calculate G(r,t) with</p> <p> TYPE: <code>list</code> </p> <code>top</code> <p>Topology object. Needed if trajectory given as a path to lazy-load.</p> <p> TYPE: <code>topology</code> DEFAULT: <code>None</code> </p> <code>pbc</code> <p>String representing the periodic boundary conditions of the simulation cell. Currently, only 'ortho' for orthogonal simulation cells is implemented.</p> <p> TYPE: <code>(string, NoneType)</code> DEFAULT: <code>string</code> </p> <code>n_windows</code> <p>Number of windows in which to split the trajectory (if a whole trajectory is supplied).</p> <p> TYPE: <code>int</code> DEFAULT: <code>100</code> </p> <code>window_size</code> <p>Number of frames in each window.</p> <p> TYPE: <code>int</code> DEFAULT: <code>200</code> </p> <code>skip</code> <p>Number of frames to skip at the beginning if giving a path as trajectory.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>stride</code> <p>Number of frames in the original trajectory to skip between each calculation. E.g. stride = 10 means calculate distances only every 10th frame.</p> <p> TYPE: <code>int</code> DEFAULT: <code>10</code> </p> <code>r_range</code> <p>Tuple over which r in g(r,t) is defined.</p> <p> TYPE: <code>tuple(float, float)</code> DEFAULT: <code>(0.0, 2.0)</code> </p> <code>nbins</code> <p>Number of bins (points in r to consider) in g(r,t)</p> <p> TYPE: <code>int</code> DEFAULT: <code>400</code> </p> RETURNS DESCRIPTION <code>r</code> <p>bin centers of g(r,t)</p> <p> TYPE: <code>array</code> </p> <code>g_rt</code> <p>averaged function values of g(r,t) for each time from t=0 considered</p> <p> TYPE: <code>array</code> </p> <p>Examples:</p> <p>First, import both <code>MDTraj</code> and <code>SPEADI</code> together.</p> <pre><code>&gt;&gt;&gt; import mdtraj as md\n&gt;&gt;&gt; import speadi as sp\n</code></pre> <p>Then, point to a particle simulation topology and trajectory (e.g. a Molecular Dynamics Simulation using <code>Gromacs</code>).</p> <pre><code>&gt;&gt;&gt; topology = './topology.gro'\n&gt;&gt;&gt; trajectory = './trajectory.xtc'\n</code></pre> <p>Next, load the topology file using <code>MDTraj</code> and start defining reference and target groups.</p> <pre><code>&gt;&gt;&gt; top = md.load_topology(topology)\n&gt;&gt;&gt; na = top.select('name NA')\n&gt;&gt;&gt; cl = top.select('name CL')\n&gt;&gt;&gt; protein_by_atom = [top.select(f'index {ix}') for\n&gt;&gt;&gt;                    ix in top.select('protein and not type H')]\n</code></pre> <p>Finally, run the Time-Resolved Radial Distribution Function (TRRDF) by calling <code>trrdf()</code>.</p> <pre><code>&gt;&gt;&gt; r, g_rt = sp.trrdf(trajectory, protein_by_atom, [na, cl], top=top,\n&gt;&gt;&gt;                     n_windows=1000, window_size=500, skip=0,\n&gt;&gt;&gt;                     pbc='general', stride=1, nbins=400)\n</code></pre> <p>The outputs are</p> <ul> <li> <p>the centre points of the radial bins <code>r</code></p> </li> <li> <p>the \\(g(r,t)\\) function with shape \\(N\\)(reference groups)\\(\\times N\\)(target groups)\\(\\times N\\)(windows)\\(\\times N\\)(radial bins)</p> </li> </ul> Source code in <code>speadi/time_resolved_rdf/trrdf.py</code> <pre><code>def trrdf(traj, g1, g2, top=None, pbc='ortho', n_windows=100, window_size=200, skip=1, stride=10, r_range=(0.0, 2.0),\n          nbins=400):\n    \"\"\"\n    Calculate g(r,t) for two groups given in a trajectory. g(r) is\n    calculated for each frame in the trajectory, then averaged over\n    specified windows of time, returning g(r,t) (where t represents\n    the window time along the trajectory).\n\n    Parameters\n    ----------\n    traj : str\n    \tString pointing to the location of a trajectory that MDTraj is\n    \table to load\n    g1 : list\n        List of numpy arrays of atom indices representing the group to\n    \tcalculate G(r,t) for\n    g2 : list\n        List of numpy arrays of atom indices representing the group to\n    \tcalculate G(r,t) with\n    top : mdtraj.topology\n        Topology object. Needed if trajectory given as a path to lazy-load.\n    pbc : {string, NoneType}\n        String representing the periodic boundary conditions of the\n    \tsimulation cell. Currently, only 'ortho' for orthogonal simulation cells\n    \tis implemented.\n    n_windows : int\n        Number of windows in which to split the trajectory (if a whole\n    \ttrajectory is supplied).\n    window_size : int\n        Number of frames in each window.\n    skip : int\n        Number of frames to skip at the beginning if giving a path as\n    \ttrajectory.\n    stride : int\n        Number of frames in the original trajectory to skip between each\n        calculation. E.g. stride = 10 means calculate distances only every\n    \t10th frame.\n    r_range : tuple(float, float)\n        Tuple over which r in g(r,t) is defined.\n    nbins : int\n        Number of bins (points in r to consider) in g(r,t)\n\n    Returns\n    -------\n    r : np.array\n        bin centers of g(r,t)\n    g_rt : np.array\n        averaged function values of g(r,t) for each time from t=0 considered\n\n    Examples\n    --------\n    First, import both `MDTraj` and `SPEADI` together.\n    &gt;&gt;&gt; import mdtraj as md\n    &gt;&gt;&gt; import speadi as sp\n\n    Then, point to a particle simulation topology and trajectory (e.g. a Molecular Dynamics Simulation using `Gromacs`).\n    &gt;&gt;&gt; topology = './topology.gro'\n    &gt;&gt;&gt; trajectory = './trajectory.xtc'\n\n    Next, load the topology file using `MDTraj` and start defining reference and target groups.\n    &gt;&gt;&gt; top = md.load_topology(topology)\n    &gt;&gt;&gt; na = top.select('name NA')\n    &gt;&gt;&gt; cl = top.select('name CL')\n    &gt;&gt;&gt; protein_by_atom = [top.select(f'index {ix}') for\n    &gt;&gt;&gt;                    ix in top.select('protein and not type H')]\n\n    Finally, run the Time-Resolved Radial Distribution Function (TRRDF) by calling `trrdf()`.\n    &gt;&gt;&gt; r, g_rt = sp.trrdf(trajectory, protein_by_atom, [na, cl], top=top,\n    &gt;&gt;&gt;                     n_windows=1000, window_size=500, skip=0,\n    &gt;&gt;&gt;                     pbc='general', stride=1, nbins=400)\n\n    The outputs are\n\n    - the centre points of the radial bins `r`\n\n    - the $g(r,t)$ function with shape $N$(reference groups)$\\\\times N$(target groups)$\\\\times N$(windows)$\\\\times N$(radial bins)\n\n    \"\"\"\n    g_rt, g1, g2 = _construct_results_array(g1, g2, n_windows, nbins)\n\n    r, g_rt = _calculate_according_to_inputs(g1, g2, g_rt, n_windows, nbins, pbc, r_range, skip, stride,\n                                             top, traj, window_size)\n\n    return r, g_rt\n</code></pre>"},{"location":"TRRDFs/#integral-of-grt-nrt","title":"Integral of g(r,t): n(r,t)","text":"<p>Provides functions to calculate the integral of theradial distribution function (RDF) between two groups of particles for specified windows along a trajectory n(r,t). Groups can also consist of single particles.</p>"},{"location":"TRRDFs/#speadi.int_trrdf.int_trrdf.int_trrdf","title":"int_trrdf","text":"<pre><code>int_trrdf(\n    traj,\n    g1,\n    g2,\n    top=None,\n    pbc=\"ortho\",\n    n_windows=100,\n    window_size=200,\n    skip=1,\n    stride=10,\n    r_range=(0.0, 2.0),\n    nbins=400,\n)\n</code></pre> <p>Calculate n(r,t) for two groups given in a trajectory. n(r) is calculated for each frame in the trajectory, then averaged over specified windows of time, returning n(r,t) (where t represents the window time along the trajectory).</p> PARAMETER DESCRIPTION <code>traj</code> <p>String pointing to the location of a trajectory that MDTraj is able to load</p> <p> TYPE: <code>str</code> </p> <code>g1</code> <p>List of numpy arrays of atom indices representing the group to calculate G(r,t) for</p> <p> TYPE: <code>list</code> </p> <code>g2</code> <p>List of numpy arrays of atom indices representing the group to calculate G(r,t) with</p> <p> TYPE: <code>list</code> </p> <code>top</code> <p>Topology object. Needed if trajectory given as a path to lazy-load.</p> <p> TYPE: <code>topology</code> DEFAULT: <code>None</code> </p> <code>pbc</code> <p>String representing the periodic boundary conditions of the simulation cell. Currently, only 'ortho' for orthogonal simulation cells is implemented.</p> <p> TYPE: <code>(string, NoneType)</code> DEFAULT: <code>string</code> </p> <code>n_windows</code> <p>Number of windows in which to split the trajectory (if a whole trajectory is supplied).</p> <p> TYPE: <code>int</code> DEFAULT: <code>100</code> </p> <code>window_size</code> <p>Number of frames in each window.</p> <p> TYPE: <code>int</code> DEFAULT: <code>200</code> </p> <code>skip</code> <p>Number of frames to skip at the beginning if giving a path as trajectory.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>stride</code> <p>Number of frames in the original trajectory to skip between each calculation. E.g. stride = 10 means calculate distances only every 10th frame.</p> <p> TYPE: <code>int</code> DEFAULT: <code>10</code> </p> <code>r_range</code> <p>Tuple over which r in n(r,t) is defined.</p> <p> TYPE: <code>tuple(float, float)</code> DEFAULT: <code>(0.0, 2.0)</code> </p> <code>nbins</code> <p>Number of bins (points in r to consider) in n(r,t)</p> <p> TYPE: <code>int</code> DEFAULT: <code>400</code> </p> RETURNS DESCRIPTION <code>r</code> <p>bin centers of n(r,t)</p> <p> TYPE: <code>ndarray</code> </p> <code>n_rt</code> <p>averaged function values of n(r,t) for each time from t=0 considered</p> <p> TYPE: <code>ndarray</code> </p> <p>Examples:</p> <p>First, import both <code>MDTraj</code> and <code>SPEADI</code> together.</p> <pre><code>&gt;&gt;&gt; import mdtraj as md\n&gt;&gt;&gt; import speadi as sp\n</code></pre> <p>Then, point to a particle simulation topology and trajectory (e.g. a Molecular Dynamics Simulation using <code>Gromacs</code>).</p> <pre><code>&gt;&gt;&gt; topology = './topology.gro'\n&gt;&gt;&gt; trajectory = './trajectory.xtc'\n</code></pre> <p>Next, load the topology file using <code>MDTraj</code> and start defining reference and target groups.</p> <pre><code>&gt;&gt;&gt; top = md.load_topology(topology)\n&gt;&gt;&gt; na = top.select('name NA')\n&gt;&gt;&gt; cl = top.select('name CL')\n&gt;&gt;&gt; protein_by_atom = [top.select(f'index {ix}') for\n&gt;&gt;&gt;                    ix in top.select('protein and not type H')]\n</code></pre> <p>Finally, run the Time-Resolved Radial Distribution Function (TRRDF) by calling <code>trrdf()</code>.</p> <pre><code>&gt;&gt;&gt; r, n_rt = sp.int_trrdf(trajectory, protein_by_atom, [na, cl], top=top,\n&gt;&gt;&gt;                         n_windows=1000, window_size=500, skip=0,\n&gt;&gt;&gt;                         pbc='general', stride=1, nbins=400)\n</code></pre> <p>The outputs are</p> <ul> <li> <p>the centre points of the radial bins <code>r</code></p> </li> <li> <p>the \\(n(r,t)\\) function with shape \\(N\\)(reference groups)\\(\\times N\\)(target groups)\\(\\times N\\)(windows)\\(\\times N\\)(radial bins)</p> </li> </ul> Source code in <code>speadi/int_trrdf/int_trrdf.py</code> <pre><code>def int_trrdf(traj, g1, g2, top=None, pbc='ortho', n_windows=100, window_size=200, skip=1, stride=10, r_range=(0.0, 2.0),\n          nbins=400):\n    \"\"\"\n    Calculate n(r,t) for two groups given in a trajectory. n(r) is\n    calculated for each frame in the trajectory, then averaged over\n    specified windows of time, returning n(r,t) (where t represents\n    the window time along the trajectory).\n\n    Parameters\n    ----------\n    traj : str\n    \tString pointing to the location of a trajectory that MDTraj is\n    \table to load\n    g1 : list\n        List of numpy arrays of atom indices representing the group to\n    \tcalculate G(r,t) for\n    g2 : list\n        List of numpy arrays of atom indices representing the group to\n    \tcalculate G(r,t) with\n    top : mdtraj.topology\n        Topology object. Needed if trajectory given as a path to lazy-load.\n    pbc : {string, NoneType}\n        String representing the periodic boundary conditions of the\n    \tsimulation cell. Currently, only 'ortho' for orthogonal simulation cells\n    \tis implemented.\n    n_windows : int\n        Number of windows in which to split the trajectory (if a whole\n    \ttrajectory is supplied).\n    window_size : int\n        Number of frames in each window.\n    skip : int\n        Number of frames to skip at the beginning if giving a path as\n    \ttrajectory.\n    stride : int\n        Number of frames in the original trajectory to skip between each\n        calculation. E.g. stride = 10 means calculate distances only every\n    \t10th frame.\n    r_range : tuple(float, float)\n        Tuple over which r in n(r,t) is defined.\n    nbins : int\n        Number of bins (points in r to consider) in n(r,t)\n\n    Returns\n    -------\n    r : np.ndarray\n        bin centers of n(r,t)\n    n_rt : np.ndarray\n        averaged function values of n(r,t) for each time from t=0 considered\n\n    Examples\n    --------\n    First, import both `MDTraj` and `SPEADI` together.\n    &gt;&gt;&gt; import mdtraj as md\n    &gt;&gt;&gt; import speadi as sp\n\n    Then, point to a particle simulation topology and trajectory (e.g. a Molecular Dynamics Simulation using `Gromacs`).\n    &gt;&gt;&gt; topology = './topology.gro'\n    &gt;&gt;&gt; trajectory = './trajectory.xtc'\n\n    Next, load the topology file using `MDTraj` and start defining reference and target groups.\n    &gt;&gt;&gt; top = md.load_topology(topology)\n    &gt;&gt;&gt; na = top.select('name NA')\n    &gt;&gt;&gt; cl = top.select('name CL')\n    &gt;&gt;&gt; protein_by_atom = [top.select(f'index {ix}') for\n    &gt;&gt;&gt;                    ix in top.select('protein and not type H')]\n\n    Finally, run the Time-Resolved Radial Distribution Function (TRRDF) by calling `trrdf()`.\n    &gt;&gt;&gt; r, n_rt = sp.int_trrdf(trajectory, protein_by_atom, [na, cl], top=top,\n    &gt;&gt;&gt;                         n_windows=1000, window_size=500, skip=0,\n    &gt;&gt;&gt;                         pbc='general', stride=1, nbins=400)\n\n    The outputs are\n\n    - the centre points of the radial bins `r`\n\n    - the $n(r,t)$ function with shape $N$(reference groups)$\\\\times N$(target groups)$\\\\times N$(windows)$\\\\times N$(radial bins)\n\n    \"\"\"\n    n_rt, g1, g2 = _construct_results_array(g1, g2, n_windows, nbins)\n\n    r, n_rt = _calculate_according_to_inputs(g1, g2, n_rt, n_windows, nbins, pbc, r_range, skip, stride,\n                                             top, traj, window_size)\n\n    return r, n_rt\n</code></pre>"},{"location":"citation/","title":"How to cite <code>speadi</code>","text":"<p>Please cite the following paper when using <code>speadi</code>:</p> <p>Please also cite the software DOI for the version you used:</p>"},{"location":"helpers/","title":"Additional Helper functions","text":""},{"location":"helpers/#speadi.common_tools.get_union.get_union","title":"get_union","text":"<pre><code>get_union(ref, target)\n</code></pre> <p>Gives the union of a single reference and a single target group, allowing \\(G(r,t)\\) to be split into \\(G_s(r,t)\\) and \\(G_t(r,t)\\).</p> PARAMETER DESCRIPTION <code>ref</code> <p>The array containing the indices of the reference particles.</p> <p> TYPE: <code>np.ndarray, dtype=int</code> </p> <code>target</code> <p>The array containing the indices of the target particles.</p> <p> TYPE: <code>np.ndarray, dtype=int</code> </p> RETURNS DESCRIPTION <code>union</code> <p>List containing the indices contained in both the reference and the target group.</p> <p> TYPE: <code>np.ndarray, dtype=int</code> </p> Source code in <code>speadi/common_tools/get_union.py</code> <pre><code>def get_union(ref, target):\n    \"\"\"Gives the union of a single reference and a single target group, allowing $G(r,t)$ to be split\n    into $G_s(r,t)$ and $G_t(r,t)$.\n\n    Parameters\n    ----------\n    ref : np.ndarray, dtype=int\n        The array containing the indices of the reference particles.\n    target : np.ndarray, dtype=int\n        The array containing the indices of the target particles.\n\n    Returns\n    -------\n    union : np.ndarray, dtype=int\n        List containing the indices contained in both the reference and the target group.\n\n    \"\"\"\n    part_union, ref_indices, target_indices = np.intersect1d(ref, target, return_indices=True, assume_unique=True)\n    union = [ref_indices, target_indices]\n\n    return union\n</code></pre>"},{"location":"helpers/#speadi.common_tools.get_union.get_all_unions","title":"get_all_unions","text":"<pre><code>get_all_unions(g1, g2, g1_lens, g2_lens)\n</code></pre> <p>Gives the union of all reference groups and all target groups, allowing \\(G(r,t)\\) to be split into \\(G_s(r,t)\\) and \\(G_t(r,t)\\).</p> PARAMETER DESCRIPTION <code>g1</code> <p>List object containing arrays of reference groups.</p> <p> TYPE: <code>list</code> </p> <code>g2</code> <p>List object containing arrays of target groups.</p> <p> TYPE: <code>list</code> </p> <code>g1_lens</code> <p>Integer number of elements in each reference group contained in g1.</p> <p> TYPE: <code>np.ndarray, dtype=int</code> </p> <code>g2_lens</code> <p>Integer number of elements in each target group contained in g2.</p> <p> TYPE: <code>np.ndarray, dtype=int</code> </p> RETURNS DESCRIPTION <code>unions</code> <p>Dictionary containing the overlapping indices in each combination of groups in g1 and g2.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>speadi/common_tools/get_union.py</code> <pre><code>def get_all_unions(g1, g2, g1_lens, g2_lens):\n    \"\"\"Gives the union of all reference groups and all target groups, allowing $G(r,t)$ to be split\n    into $G_s(r,t)$ and $G_t(r,t)$.\n\n    Parameters\n    ----------\n    g1 : list\n        List object containing arrays of reference groups.\n    g2 : list\n        List object containing arrays of target groups.\n    g1_lens : np.ndarray, dtype=int\n        Integer number of elements in each reference group contained in g1.\n    g2_lens : np.ndarray, dtype=int\n        Integer number of elements in each target group contained in g2.\n\n    Returns\n    -------\n    unions : dict\n        Dictionary containing the overlapping indices in each combination of groups in g1 and g2.\n\n    \"\"\"\n    Ng1 = g1_lens.shape[0]\n    Ng2 = g2_lens.shape[0]\n\n    unions = {}\n    for i in range(Ng1):\n        unions[str(i)] = {}\n        for j in range(Ng2):\n            unions[str(i)][str(j)] = get_union(g1[i], g2[j])\n\n    return unions\n</code></pre>"},{"location":"helpers/#speadi.common_tools.check_acceleration.check_jax","title":"check_jax","text":"<pre><code>check_jax()\n</code></pre> <p>Checks the availability of <code>jax</code> and the <code>jaxlib</code> library in the current python environment.</p> RETURNS DESCRIPTION <code>JAX_AVAILABLE</code> <p>Boolean variable that other functions can use to import the correct accelerated versions of code.</p> <p> TYPE: <code>bool</code> </p> Source code in <code>speadi/common_tools/check_acceleration.py</code> <pre><code>def check_jax():\n    \"\"\"Checks the availability of `jax` and the `jaxlib` library in the current python environment.\n\n    Returns\n    -------\n    JAX_AVAILABLE : bool\n        Boolean variable that other functions can use to import the correct accelerated versions of code.\n\n    \"\"\"\n    JAX_AVAILABLE = False\n    try:\n        from jax import __version__ as __jax_version\n        from jaxlib import __version__ as __jaxlib_version\n        JAX_AVAILABLE = True\n    except ImportError:\n        JAX_AVAILABLE = False\n\n    return JAX_AVAILABLE\n</code></pre>"},{"location":"helpers/#speadi.common_tools.check_acceleration.check_numba","title":"check_numba","text":"<pre><code>check_numba()\n</code></pre> <p>Checks the availability of <code>numba</code> in the current python environment.</p> RETURNS DESCRIPTION <code>NUMBA_AVAILABLE</code> <p>Boolean variable that other functions can use to import the correct accelerated versions of code.</p> <p> TYPE: <code>bool</code> </p> Source code in <code>speadi/common_tools/check_acceleration.py</code> <pre><code>def check_numba():\n    \"\"\"Checks the availability of `numba` in the current python environment.\n\n    Returns\n    -------\n    NUMBA_AVAILABLE : bool\n        Boolean variable that other functions can use to import the correct accelerated versions of code.\n\n    \"\"\"\n    NUMBA_AVAILABLE = False\n    try:\n        from numba import __version__ as __numba_version__\n        NUMBA_AVAILABLE = True\n    except ImportError:\n        NUMBA_AVAILABLE = False\n\n    return NUMBA_AVAILABLE\n</code></pre>"},{"location":"references/","title":"References used in <code>speadi</code>","text":"<p>.. [vanhove54] L\u00e9on van Hove (1954). \"Correlations in space and time and born approximation scattering in systems of      interacting particles.\" Physical Review, 95(1), 249\u2013262. [http://dx.doi.org/10.1103/physrev.95.249] </p>"},{"location":"vanhove/","title":"van Hove Correlation Functions (TRRDFs)","text":""},{"location":"vanhove/#van-hove-function-grt","title":"van Hove function G(r,t)","text":"<p>Provides functions to calculate the vanhove dynamic correlation function G(r,t) between two groups of particles. Groups can also consist of single particles.</p>"},{"location":"vanhove/#speadi.vanhove.vanhove.vanhove","title":"vanhove","text":"<pre><code>vanhove(\n    traj,\n    g1,\n    g2,\n    top=None,\n    pbc=\"ortho\",\n    n_windows=100,\n    window_size=200,\n    overlap=False,\n    skip=1,\n    stride=10,\n    r_range=(0.0, 2.0),\n    nbins=400,\n    self_only=False,\n)\n</code></pre> <p>Calculate \\(G(r,t)\\) for two groups given in a trajectory. \\(G(r,t)\\) is calculated for a smaller time frame (typically 2 ps). \\(G(r,t)\\) is then averaged over the whole trajectory supplied.</p> <p>\\(G(r,t)\\) is calculated as:</p> \\[G_{ab}(r,t) = \\frac{1}{4\\pi\\rho_{b}N_{a}r^2} \\sum^{N_a}_{i=1}   \\sum^{N_b}_{j=1} \\delta(|r_i(0) - r_j(t)| - r)\\] <p>following the formulation by Shinohara, Y. et al. [1]</p> <p>The function was originally published by L\u00e9on van Hove in 1954. [2]</p> PARAMETER DESCRIPTION <code>traj</code> <p>MDTraj trajectory, or Generator of trajectories (obtained using mdtraj.iterload).</p> <p> TYPE: <code>(string, trajectory, Generator)</code> DEFAULT: <code>string</code> </p> <code>g1</code> <p>List of numpy arrays of atom indices representing the group to calculate \\(G(r,t)\\) for.</p> <p> TYPE: <code>list</code> </p> <code>g2</code> <p>List of numpy arrays of atom indices representing the group to calculate \\(G(r,t)\\) with.</p> <p> TYPE: <code>list</code> </p> <code>top</code> <p>Topology object. Needed if trajectory given as a path to lazy-load.</p> <p> TYPE: <code>topology</code> DEFAULT: <code>None</code> </p> <code>pbc</code> <p>String representing the periodic boundary conditions of the simulation cell. Currently, only 'ortho' for orthogonal simulation cells is implemented.</p> <p> TYPE: <code>(string, NoneType)</code> DEFAULT: <code>string</code> </p> <code>n_windows</code> <p>Number of windows in which to split the trajectory (if a whole trajectory is supplied).</p> <p> TYPE: <code>int</code> DEFAULT: <code>100</code> </p> <code>window_size</code> <p>Number of frames in each window.</p> <p> TYPE: <code>int</code> DEFAULT: <code>200</code> </p> <code>overlap</code> <p>Positive integer number of frames between overlapping windows.</p> <p> TYPE: <code>(int, False)</code> DEFAULT: <code>int</code> </p> <code>skip</code> <p>Number of frames to skip at the beginning if giving a path as trajectory.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>stride</code> <p>Number of frames in the original trajectory to skip between each calculation. E.g. stride = 10 means calculate distances only every 10th frame.</p> <p> TYPE: <code>integer</code> DEFAULT: <code>10</code> </p> <code>r_range</code> <p>Tuple over which r in \\(G(r,t)\\) is defined.</p> <p> TYPE: <code>tuple(float, float)</code> DEFAULT: <code>(0.0, 2.0)</code> </p> <code>nbins</code> <p>Number of bins (points in r to consider) in \\(G(r,t)\\)</p> <p> TYPE: <code>int</code> DEFAULT: <code>400</code> </p> RETURNS DESCRIPTION <code>r</code> <p>bin centers of \\(G(r,t)\\)</p> <p> TYPE: <code>array</code> </p> <code>G_self</code> <p>averaged function values of \\(G_{s}(r,t)\\) for each time from t=0 considered</p> <p> TYPE: <code>ndarray</code> </p> <code>G_distinct</code> <p>averaged function values of \\(G_{d}(r,t)\\) for each time from t=0 considered</p> <p> TYPE: <code>ndarray</code> </p> <p>Examples:</p> <p>First, import both <code>MDTraj</code> and <code>SPEADI</code> together.</p> <pre><code>&gt;&gt;&gt; import mdtraj as md\n&gt;&gt;&gt; import speadi as sp\n</code></pre> <p>Then, point to a particle simulation topology and trajectory (e.g. a Molecular Dynamics Simulation using <code>Gromacs</code>).</p> <pre><code>&gt;&gt;&gt; topology = './topology.gro'\n&gt;&gt;&gt; trajectory = './trajectory.xtc'\n</code></pre> <p>Next, load the topology file using <code>MDTraj</code> and start defining reference and target groups.</p> <pre><code>&gt;&gt;&gt; top = md.load_topology(topology)\n&gt;&gt;&gt; na = top.select('name NA')\n&gt;&gt;&gt; cl = top.select('name CL')\n&gt;&gt;&gt; protein_by_atom = [top.select(f'index {ix}') for\n&gt;&gt;&gt;                    ix in top.select('protein and not type H')]\n</code></pre> <p>Finally, run the van Hove Function (VHF) by calling <code>vanhove()</code>.</p> <pre><code>&gt;&gt;&gt; r, g_s, g_d = sp.vanhove(trajectory, protein_by_atom, [na, cl], top=top,\n&gt;&gt;&gt;                           n_windows=1000, window_size=500, skip=0,\n&gt;&gt;&gt;                           pbc='general', stride=1, nbins=400)\n</code></pre> <p>The outputs are</p> <ul> <li> <p>the centre points of the radial bins <code>r</code></p> </li> <li> <p>the \\(G_s(r,t)\\) self part of the correlation function with shape   \\(N\\)(reference groups)\\(\\times N\\)(\\tau windows)\\(\\times N\\)(radial bins)</p> </li> <li> <p>the \\(G_s(r,t)\\) self part of the correlation function with shape   \\(N\\)(reference groups)\\(\\times N\\)(target groups)\\(\\times N\\)(\\tau windows)\\(\\times N\\)(radial bins)</p> </li> </ul> References <p>[1] Shinohara, Y., Matsumoto, R., Thompson, M. W. et al., \"Identifying water-anion        correlated motion in aqueous solutions through van Hove functions,\"        The Journal of Physical Chemistry Letters, 10(22), 7119\u20137125 (2019).        http://dx.doi.org/10.1021/acs.jpclett.9b02891</p> <p>[2] van Hove, L., \"Correlations in space and time and Born approximation scattering        in systems of interacting particles\", Physical Review, 95(1), 249\u2013262 (1954).        http://dx.doi.org/10.1103/physrev.95.249</p> Source code in <code>speadi/vanhove/vanhove.py</code> <pre><code>def vanhove(traj, g1, g2, top=None, pbc='ortho', n_windows=100, window_size=200, overlap=False, skip=1, stride=10,\n            r_range=(0.0, 2.0), nbins=400, self_only=False):\n    \"\"\"\n    Calculate $G(r,t)$ for two groups given in a trajectory.\n    $G(r,t)$ is calculated for a smaller time frame (typically 2 ps). $G(r,t)$ is\n    then averaged over the whole trajectory supplied.\n\n    $G(r,t)$ is calculated as:\n\n    $$G_{ab}(r,t) = \\\\frac{1}{4\\\\pi\\\\rho_{b}N_{a}r^2} \\\\sum^{N_a}_{i=1}\n      \\\\sum^{N_b}_{j=1} \\\\delta(|r_i(0) - r_j(t)| - r)$$\n\n\n    following the formulation by Shinohara, Y. et al. [1]\n\n    The function was originally published by L\u00e9on van Hove in 1954. [2]\n\n    Parameters\n    ----------\n    traj : {string, mdtraj.trajectory, Generator}\n        MDTraj trajectory, or Generator of trajectories (obtained using\n    \tmdtraj.iterload).\n    g1 : list\n        List of numpy arrays of atom indices representing the group to\n    \tcalculate $G(r,t)$ for.\n    g2 : list\n        List of numpy arrays of atom indices representing the group to\n    \tcalculate $G(r,t)$ with.\n    top : mdtraj.topology\n        Topology object. Needed if trajectory given as a path to lazy-load.\n    pbc : {string, NoneType}\n        String representing the periodic boundary conditions of the simulation\n    \tcell. Currently, only 'ortho' for orthogonal simulation cells is\n    \timplemented.\n    n_windows : int\n        Number of windows in which to split the trajectory (if a whole\n    \ttrajectory is supplied).\n    window_size : int\n        Number of frames in each window.\n    overlap : {int, False}\n        Positive integer number of frames between overlapping windows.\n    skip : int\n        Number of frames to skip at the beginning if giving a path as\n    \ttrajectory.\n    stride : integer\n        Number of frames in the original trajectory to skip between each\n        calculation. E.g. stride = 10 means calculate distances only every\n    \t10th frame.\n    r_range : tuple(float, float)\n        Tuple over which r in $G(r,t)$ is defined.\n    nbins : int\n        Number of bins (points in r to consider) in $G(r,t)$\n\n    Returns\n    -------\n    r : np.array\n        bin centers of $G(r,t)$\n    G_self  : np.ndarray\n        averaged function values of $G_{s}(r,t)$ for each time from t=0 considered\n    G_distinct  : np.ndarray\n        averaged function values of $G_{d}(r,t)$ for each time from t=0 considered\n\n    Examples\n    --------\n    First, import both `MDTraj` and `SPEADI` together.\n    &gt;&gt;&gt; import mdtraj as md\n    &gt;&gt;&gt; import speadi as sp\n\n    Then, point to a particle simulation topology and trajectory (e.g. a Molecular Dynamics Simulation using `Gromacs`).\n    &gt;&gt;&gt; topology = './topology.gro'\n    &gt;&gt;&gt; trajectory = './trajectory.xtc'\n\n    Next, load the topology file using `MDTraj` and start defining reference and target groups.\n    &gt;&gt;&gt; top = md.load_topology(topology)\n    &gt;&gt;&gt; na = top.select('name NA')\n    &gt;&gt;&gt; cl = top.select('name CL')\n    &gt;&gt;&gt; protein_by_atom = [top.select(f'index {ix}') for\n    &gt;&gt;&gt;                    ix in top.select('protein and not type H')]\n\n    Finally, run the van Hove Function (VHF) by calling `vanhove()`.\n    &gt;&gt;&gt; r, g_s, g_d = sp.vanhove(trajectory, protein_by_atom, [na, cl], top=top,\n    &gt;&gt;&gt;                           n_windows=1000, window_size=500, skip=0,\n    &gt;&gt;&gt;                           pbc='general', stride=1, nbins=400)\n\n    The outputs are\n\n     - the centre points of the radial bins `r`\n\n     - the $G_s(r,t)$ self part of the correlation function with shape\n      $N$(reference groups)$\\\\times N$(\\\\tau windows)$\\\\times N$(radial bins)\n\n     - the $G_s(r,t)$ self part of the correlation function with shape\n      $N$(reference groups)$\\\\times N$(target groups)$\\\\times N$(\\\\tau windows)$\\\\times N$(radial bins)\n\n    References\n    -------\n    [1] Shinohara, Y., Matsumoto, R., Thompson, M. W. et al., \"Identifying water-anion\n           correlated motion in aqueous solutions through van Hove functions,\"\n           The Journal of Physical Chemistry Letters, 10(22), 7119\u20137125 (2019).\n           http://dx.doi.org/10.1021/acs.jpclett.9b02891\n\n    [2] van Hove, L., \"Correlations in space and time and Born approximation scattering\n           in systems of interacting particles\", Physical Review, 95(1), 249\u2013262 (1954).\n           http://dx.doi.org/10.1103/physrev.95.249\n\n    \"\"\"\n    G_self, G_distinct, g1, g2 = _construct_results_array(g1, g2, nbins, stride, window_size)\n\n    r, G_self, G_distinct, n_windows = _calculate_according_to_inputs(G_self, G_distinct, g1, g2, n_windows, nbins,\n                                                                      overlap, pbc, r_range, self_only, skip, stride,\n                                                                      top, traj, window_size)\n    G_self = G_self / n_windows\n    G_distinct = G_distinct / n_windows\n    return r, G_self, G_distinct\n</code></pre>"}]}